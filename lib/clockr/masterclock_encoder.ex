defmodule Clockr.MasterclockEncoder do
  @moduledoc """
  Utilities for generating Masterclock packets
  """

  use Bitwise

  @hdr1     [0x23, 0x81, 0xd7, 0x65]
  @hdr2     [0x10, 0xb3, 0x2f, 0xe1]
  @rsrv1    [0x00, 0x00]
  @family   [0x00, 0x00, 0x00, 0x80]
  @rsrv2    [0x00, 0x00, 0x00]
  @zeroes   [0x01] # Leading Zeroes (off): Set to 0x00 to enable
  @rsrv3    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

  @controlcodes %{
    default: 0x00, # alias for :time
    time:    0x00,
    blank:   0x01,
    value:   0x02,
    dashes:  0x03,
  }

  @doc """
    Creates a masterclock control packet from an instruction.

    ## Examples

        iex> Clockr.MasterclockEncoder.packetize({:blank, %{h: 0, m: 0, s: 0}}, 1)
        [0x23, 0x81, 0xD7, 0x65, 0x10, 0xB3, 0x2F, 0xE1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00]

        iex> Clockr.MasterclockEncoder.packetize({:dashes, %{h: 0, m: 0, s: 0}}, 1)
        [0x23, 0x81, 0xD7, 0x65, 0x10, 0xB3, 0x2F, 0xE1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00]

        iex> Clockr.MasterclockEncoder.packetize({:time, %{h: 0, m: 0, s: 0}}, 1)
        [0x23, 0x81, 0xD7, 0x65, 0x10, 0xB3, 0x2F, 0xE1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

        iex> Clockr.MasterclockEncoder.packetize({:value, %{h: 12, m: 30, s: 0}}, 1)
        [0x23, 0x81, 0xD7, 0x65, 0x10, 0xB3, 0x2F, 0xE1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0C, 0x1E]

        iex> Clockr.MasterclockEncoder.packetize({:value, %{h: 12, m: 30, s: 0}}, 0xfff)
        [0x23, 0x81, 0xD7, 0x65, 0x10, 0xB3, 0x2F, 0xE1, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0C, 0x1E]
    """
  def packetize({mode, hms}, control_source_id) do
    @hdr1 ++
    @hdr2 ++
    @rsrv1 ++
    integer_to_bytes(control_source_id) ++
    @family ++
    @rsrv2 ++
    @zeroes ++
    @rsrv3 ++
    [@controlcodes[mode]] ++
    [hms.s, hms.h, hms.m]
  end

  defp integer_to_bytes(id) do
    # Convert numbers 0-65535 into 2-byte representation
    # Take the most significant 8 bits and shift right so they become the first byte
    # Then, mask off the least significant 8 bits so they remaining become the second byte
    [id >>> 8, id &&& 0xff]
  end
end
